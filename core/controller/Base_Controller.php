<?php
defined('SHOP') or exit('Access denied');
// Создаем ядро нашего сайта абстрактный класс Base_Controller
abstract class Base_Controller {
//Создаем свойства класса с доступом protected,что означает доступ в этом классе и в наследуемых   
    protected $request_url;//Здесь будет путь к файлу переданный сюда Route_Controller
    
    protected $controller;//Здесь контролер так же переданный от Route_Controller
    
    protected $params;//Здесь массив параметров и их значений так же от Route_Controller
    
    protected $styles,$styles_admin;//Здесь наши стили переданные из нашего config.php
    
    protected $scripts,$scripts_admin;//см.выше
    
    protected $error;//Здесь будут храниться данныу об ошибках обрабатываемые в классе Base_Error
    
    protected $page;//В этом свойстве будет храниться страничка генерированая методом function output()  готовая к выводу 
    
    //Напишем метод Route который будет получать данные из Route_Controller и вызывать нужный контроллер а также вызвать метод
    //request в полученом контролер,можно было напрямую вызвать контьролер который хранится в свойстве 
    //$controller и обратиться к методу request,но мы сделаем красивее и с проверкой
    /*Мы воспользуемся расширением языка PHP и его встроенным классом Reflaction с помощью методов которого можно узнать и исполь
    зовать все свойства того или иного класса его методы вообщем все о любом классе непосредственно в браузере а не искать в коде
    а потом проверим ,а существует ли вообще класс который записан в нашем свойстве $controller воспользуемся функцикй class_exists из
    встроенного в PHP класса Reflaction, которая возвращает TRUE или FALSE. Метод Rout изходя из данных
    которые нам запишет Rout_Controller  в свойства $controller загрузит нужный нвм котролер у этого контролера вызовет главный метод и этому
    методу передаст $params параметры*/
    public function route() {
        if(class_exists($this->controller)) {
            //Если да то созданим какуюто переменную где сохраним обьект класса ReflectionClass и передадим конструктору этого класса
            //имя нашего класса которое хранится в свойстве $controller
            $ref = new ReflectionClass($this->controller);
            
            /*Теперь с помощью метода hasMethod класса ReflectionClass проверим есть ли в классе $this->controller
            метод request*/
            if($ref->hasMethod('request')) {
                
                //Теперь проверим а можно ли получить обьект из класса имя которого хранится в $this->controller
                if($ref->isInstantiable()) {
                    //Если TRUE то вызовем обькт этого класса и сохраним в переменную
                    $class = $ref->newInstance();//метод newInstance() класса ReflectionClass позволяет получить обьект
                    
                    /*Теперь нам необходимо вызвать для этого обьекта метод request, т.е. вызвать его на исполнение т.е
                    нам необходимо уже использовать класс ReflectionMethod и получить его обьект,для это мы опять же обьявляем
                    какуюто переменную и получаем в нее какбы отражение метода request.Т.е. мы получили обьект который сохранили в переменную
                    обьект класса ReflectionMethod как бы отражение метода request*/
                    $method = $ref->getMethod('request');
                    
                    /*Теперь нам надо обратиться к методу invoke класса ReflectionMethod чтобы запустить исполнение метода 
                    request и передать ему параметры- сам обьект и массив параметров которые мы должны передать методу request*/
                    $method->invoke($class,$this->get_params());//get_params()-метод Base_Controller,можно просто $this->params                                          
                }   
            }    
        }
        //Если нет то сгенирируем исключение
        else {
            throw new ContrException("Такой страницы не существует","Контроллер - ".$this->controller);
        }    
    }
    
    //Теперь напишем метод который будет формировать массив со стилями и массив со скриптами
    public function init(){
        global $conf;//Т.к. массив $conf не является свойстом класса то чтобы полцчить к нему доступ обьявляем его Global
        //Так как работать удобнеее со свойствами класса а не с глобальной переменной,поэтому мы перепишем данные
        //с глобального массива $conf и присвоим их соответствующим свойствам нашего класса
        //Теперь проверим есть ли в массиве $conf ячейка styles(массив находится в файле config.php)
        if (isset ($conf['styles'])) {
            foreach ($conf['styles'] as $style) {
                $this->styles[] = trim($style,'/');//Обращаемся к нашему свойству $styles и присваеваем ему полученный масив $style из цикла
                //См.выше/с помощью функции trim мы убираем если пользователь случайно поставил / в файле config.php               
            }
        }
        //Теперь тоже для админ.страницы
        if (isset ($conf['styles_admin'])) {
            foreach ($conf['styles_admin'] as $style_admin) {
                $this->styles_admin[] = trim($style_admin,'/');//Обращаемся к нашему свойству $styles и присваеваем ему полученный масив $style из цикла
                //См.выше/с помощью функции trim мы убираем если пользователь случайно поставил / в файле config.php               
            }
        }
        
        //Теперь то же для скриптов
        if (isset ($conf['scripts'])) {
            foreach ($conf['scripts'] as $script) {
                $this->scripts[] = trim($script,'/');//формируем свойство $scripts на основе данных нашего цикла
            }
        }
        
         if (isset ($conf['scripts_admin'])) {
            foreach ($conf['scripts_admin'] as $script_admin) {
                $this->scripts_admin[] = trim($script_admin,'/');//формируем свойство $scripts на основе данных нашего цикла
            }
        }
    }
    
    
    //Теперь создаем метод,который нам будет возвращать данные по контроллеру protected $controller
    protected function get_controller() {
        return $this->controller;
    }
    
    //Теперь метод который будет возвращать массив $params 
    protected function get_params() {
        return $this->params;
    }
    
    //Теперь опишем два метода которые сдесь остануться пустые, а кодом наполнятся
    //в следующих дочерних классах, тут мы просто опишем,что будут какие то входные данные т.д.
    //а в дочерних классах создадутся методы с точно таким же названием и наполнятся кодом
    protected function input() {
        
    }
    
    //А этот метод будет на основе тех данных,которые получит от метода input выводить данные на
    //страничку и так же переопределится в дочерних классах-наполнится кодом
    //в дочернем кдассе создадится метод с точно таким название и пропишется код
    // и это будет называться перезагрузкой метода
    protected function output() {
        
    }
    
    //А теперь самый главный метод, который будет вызываться методом public function route
    //из любого контроллера дочерних классов.На основании данных от route_controllers -метод
    //public function route() бедет вызывать этот метод и данные $params,которые мы ему передаем в 
    //качестве параметров, по умолчанию делаем его пустым (= array())
    /*Логика такая- как только пользователь вводит запрос в адрессной строке,мы формируем контроллер и параметры
    дальше метод route вызывает этот контроллер и вызывает метод request у этого контролера.Метод request должен сначала
    получить параметры конфигурации,т.е. вызвать метод init далее надо сформировать какие то входные
    данные этим занимается метод input() и передаем ему параметры т.е. массив $param см.ниже
    и дальше отдать эту страничку для вывода на экран- метод function output()*/
    public function request($param = array()) {
        $this->init();
        $this->input($param);
        $this->output();
        
        /*Прежде чем выводить на экран мы с помощью функции emty пустое ли у нас значение 
        свойства $error если не пустое то вызываем метод write_error который будет записывать то что 
        находится в свойстве $this->error ошибки в log.txt*/ 
        if(!empty($this->error)) {
            $this->write_error($this->error);    
        } 
        //Если ошибок нет то с помощью метода get_page,который опишем ниже выведим нашу страничку
        $this->get_page();  
    }
    
    //Опишем метод get_page и передадим ему параметр $page где будет храниться наша страничка
    //сгенерированная методом function output()
    public function get_page() {
        echo $this->page;//Обращаемся к свойству где хранится наша страничка
    }
    
    /* Теперь опишем метод,который будет выступать как шаблонизатор он будет получать два
    параметра - это путь к нашему файлу шаблона $path и массив переменных $param которые необходимо 
    передать в этот шаблон*/
    public function render($path,$param = array()) {
        extract($param);/*Функция extract создает в памяти переменые из массива,который ей передали*/
        //Теперь вызывает метод открытия буфера обмена
        ob_start();
        //Подключаем наш шаблон и пристыковываем расширение,что бы был путь
        /*С проверкой на случай если не оказалось шаблона и сгенерируем исключение с помощью
        функции throw , а класс ContrException() будет обрабатывать у нас исключения связанные с
        контроллерами, но об этом позже*/
        if(!include($path.'.php')) {
            throw new ContrException('Данного шаблона нет');    
        }
        //Если все нормально то вернем данные из буфера обмена с помощью функции ob_get_clean
        return ob_get_clean();    
    }
    
    /*Теперь опишем метод который будет очищать строки данных которые мы получаем отпользователя
    методом POST. так как методом GET в нашем случае мы получать не будем для того чтобы какойто
    вредноносный код не попал в наши скрипты*/
    /*С помощью функции trim мы очистим нашу строку, а с помощью функции strip_tags удалим
    лишние теги чтобы злоумышленик не прописал какойто лишний код*/
    public function clear_str($var) {
        if(is_array($var)) {  //Это если массив
            $row = array();   //Создаем промежуточный пустой массив
            foreach($var as $key=>$item) {  //В цикле по значениям $key и $item пробегаем наш массив 
                $row[$key] = trim(strip_tags($item)); //И формируем наш массив с очищенными строками   
            }
            return $row;//И в конце цикла возвращаем наш очищенный массив   
        }       
        return trim(strip_tags($var));//Это для строки   
    }
    
    //Теперь опишем метод для очистки числовых данных полученных
    public function clear_int($var) {
        return (int)$var;//С помощью (int)мы жестко все данные $var переводим в числовое значение
    }
    
    //Теперь опишем метод который будет проверять пришли ли данные методом POST
    public function is_post() {
        /*Чтобы проверить пришли ли данныу нужно проверить суперглобальный массив SERVER
        ячейку REQUEST_METHOD И если в ней содержится строка POST значит данные */
        if($_SERVER['REQUEST_METHOD'] == 'POST') {
            return TRUE;        
        }
        return FALSE;
                
    }
    
    //Пропишем пустой метод проверки авторизации пользователя, который опишем позже, когда
    //будем писать админ часть
    public function check_auth() {
        /*это метод вызывается в Base_Admin,из Admin_Contr метода,которые будут проверять авторизирован пользователь или нет опишем в блоке try,и если
        нет то сразу сгенерируем исключение и попадем в блок catch,где запишем в файл logo о попытке
        входа и перенаправим пользователя на страницу выторизации*/
        try {
            $cookie = Model_User::get_instance();
            /*у обьекта $cookie вызовем метод check_id_user из Model_User,который будет вытаскивать id из куки файла*/
            $cookie->check_id_user();
            /*теперь обратимся к методу который будет проверять правильно ли составлен файл куки,когда мы в админке*/
            $cookie->validate_cookie();    
        }
        catch(AuthException $e) {
            //сначала в свойстве error сохнаним такую строку,а ниже пристыуцем уже конкретное сообщение
            $this->error = "Ошибка авторизации пользователя | ";
            
            //обратимся к свойству error и сохраним в нем сообщение об ошибке
            $this->error .= $e->getMessage();
            
            //запишем сообщение об ошибке в наш log.php
            $this->write_error($this->error);
            
            header("Location:".SITE_URL."Login");//и перенаправим на контролер login
            exit();    
        }    
    }
    
    /*Пропишем теперь метод write_error который вызывался выше в методе request для 
    записи ошибок*/
    public function write_error($err) {
        $time = date("d-m-Y G:i:s");//С помощью функции date запишем в переменную $time время ошибки
        /*Теперь сформируем строку для записи об ошибке,*/
        $str = "Fault: ".$time." - ".$err. "\n\r";
        file_put_contents("log.txt",$str,FILE_APPEND);//С помощью этой функции записываем в наш файл log.txt
    }
    
    /*Пропишем метод ,который заполним когда будем писать админку, метод который будет
    уменьшать размеры загружаемых img до нужного нам размера и который в качестве параметра
    будет принимать путь к файлу*/
    public function img_resize($dest,$type) {//где $dest путь к нашей картинке
        
        switch($type) {
            case 'jpeg':
            //создадим переменую где будет рессурс исходного изображения полученный методом imageCreatFromJpeg
            /*исходный файл также должен быть в формате jpeg если мы хотим чтобы загружались файлы других форматов,то
            надо кроме $dest еще передать type и неже прописать тоже только с другими ф-ми котоые записывают в других
            формата и в зависимости от исходного файла использовать ту или иную функцию, а нам достаточно только jpeg*/
                $img_id = imagecreatefromjpeg($dest);
            break;
            
            /*если бы мы позволяли загружать еще и другие форматы,т.е. в Edit_Catalog в массиве типов были и другие то надо 
            case 'png'
                $img_id = imagecreatefromPNG($dest);
            break;*/    
        }
        
        //создадим переменую где будет рессурс исходного изображения полученный методом imageCreatFromJpeg
        /*исходный файл также должен быть в формате jpeg если мы хотим чтобы загружались файлы других форматов,то
        надо кроме $dest еще передать type и неже прописать тоже только с другими ф-ми котоые записывают в других
        формата и в зависимости от исходного файла использовать ту или иную функцию, а нам достаточно только jpeg*/
        $img_id = imagecreatefromjpeg($dest);
        
        //теперь получим ширину и длину изображения чтобы пропорционально уменьшить
        $img_width = imageSX($img_id);//ширина
        $img_height = imagesy($img_id);//высота 
        
        /*теперь для пропорционального изменения нам надо вычислить коэфициент,т.е.если ширину надо уменьшить
        в два раза значить и высоту в два раза -создадим переменную и вней будет коэфициент*/
        $k = round($img_width/IMG_WIDTH,2);//т.е.делим на нашу константу и округляем,чтобы было целое число
        
        //теперь имея коэфициент создадим переменые где уже будут мини нирина и высота
        $img_mini_width = round($img_width/$k);
        $img_mini_height = round($img_height/$k);        
        
        //теперь создадим новое пусстое изображение на котором мы и создадим нашу миниатюру
        $img_dest_id = imagecreatetruecolor($img_mini_width,$img_mini_height);
        
        /*теперь в этом пустом изображении надо создать уменьшенную копию исходного изображения*/
        $result = imagecopyresampled($img_dest_id,//на какой ресурс
                                     $img_id,     //из какого русурса
                                     0,0,0,0,     //координады искажения
                                     $img_mini_width,//ширина необходима
                                     $img_mini_height,//высота необходимая
                                     $img_width,      //ширина исходная
                                     $img_height);    //исходная высота
        /*теперь нам надо сохранить полученое изображение и дать ему имя(сгенерировать случайною строку)*/
        $name_img = $this->rand_str().'.jpg';//обращаемся к методу который описан тут же и генерирует случайною строку
        
        //теперь создадим перем.и сохраним в ней отработку метода который созлает изображения
        $img = imagejpeg($img_dest_id,UPLOAD_DIR.$name_img,100);//100 - это качество изображ.в процентах
        
        //теперь очистим память,то есть поудаляем наши ресурсы
        imagedestroy($img_id);
        imagedestroy($img_dest_id);
        //теперь проверим если файл создан то вернем имя этого файла
        if($img) {
            return $name_img;    
        }
        else {
            return FALSE; 
        }
    }
    
    //метод генерации случайной строки для имени изображения например
    protected function rand_str() {
        
        //в переменную $str сохраним метку времени защифрованною в md5
        $str = md5(microtime());
        //и вернем обрезанноу например до 10 символа эту строку
        return substr($str,0,10);    
    }
    
    
}
?>