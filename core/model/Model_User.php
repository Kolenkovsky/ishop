<?php
defined('SHOP') or exit('Access denied');
//Создадим модель ,которая будет у нас работать с пользователем,так же по типу сингл тон
class Model_User {
    
    protected $ins_driver_u;//в этом свойство будет хранить обьект класса Model_Driver
    
    protected $user_id;//здесь будем хранить индефикатор польз.,который получили в методе get_user
    
    protected $glue = "|";//это склеиватель строки,который будем применять для формирования для записи куки
    ///////////////
    private $td;//здесь будем хранить дескриптор открытого модуля MCRIPT расширения php для шифрования
    
    private $cyfer = MCRYPT_BLOWFISH;//это способ шифрования из расширения mcrypt
    
    private $mode = MCRYPT_MODE_CFB;//это режим шифрования так же из расширения php mcrypt
    
    private $created;//сюда запишем время создания куки
    
    private $version;//здесь версию файла куки
    ///////////////////////////
    static $instance;
    
    static $cookie_name = 'USERNAME';//здесь будет хранить имя куки файла и по умолчанию имя будет USERNAME
    
    //Опишем главный метод сингл тона
    static function get_instance() {
        /*Проверяем в свойстве $instance записан ли обьект класса Model*/
        if(self::$instance instanceof self) {
            return self::$instance;    
        }
        //Если условие не выполняется то создаем обьект
        return self::$instance = new self;
    }
    
    //Опишем закрытый конструктор модели
    private function __construct() {
        
        //сохраним обьект класса Model_Driver в нашем свойстве $ins_driver_u
        $this->ins_driver_u = Model_Driver::get_instance();
        ///////////////////////////////////////////////////////////
        /*теперь начнем шифровать,с перва открываем модуль mcrypt и получаем его дескриптор и сохраняем
        в нашем свойстве $td параметрами передаем способ шифрования,режим шифрования,и пустые ячейки 
        это путь к дерикториям их,но мы используем стандартные-поэтому пусто,если бы свои способ и режим 
        то указалибы путь к дериктории*/
        $this->td = mcrypt_module_open($this->cyfer,'',$this->mode,'');  
    }
    
    /*опишем метод который будет вытаскивать индефикатор пользователя из базы данных при его ауденфикации
    id нам нужен для записи в строку файла cookie, параметры в медот приходят из Login_Controller*/
    public function get_user($name,$password) {
    
        //создадим промежуточн.перемен. и обратимся к обьекту Model_Driver и его методу select для выборки
        $result = $this->ins_driver_u->select(
                                              array('user_id'),
                                              'users',
                                              array('login' => $name,'password' => md5($password))//так же зашифруем парол как в базе
                                             );
        /*теперь проверим если вернуло ноль или false то сгенерируем исключение*/
        if($result==NULL || $result==FALSE) {
            throw new AuthException("Такой пользователь не найден");
            return;//и сразу выходим из метода   
        }
        
        /*если условие выше не выполнилось,то мы проверим является ли $result массивом*/
        if(is_array($result)) {
            //чтобы без цикла сделаем так,т.е. вернем непосредственно индефикатор пользователя
            return $result[0]['user_id'];    
        }     
    }
    
    /*опишем метод,который позволит сохранить количество неудачных попыток пользователя войти с одним ip
    нам надо вытащить все поля fealtures пользователя с этим ip,поэтому обратимся к обьекту Model_Draver
    и его метотоду select*/
    public function get_fealtures($ip) {
        //создадим промеж.переменную и
        $result = $this->ins_driver_u->select(
                                              array('fealtures'),
                                              'fealtures',
                                              array('ip' => $ip)
                                             );
        /*теперь проверим были ли неправильные попытки и сколько*/
        if(count($result) == 0) {
            return NULL;    
        }
        //иначе если проверка не прошла и там есть записи
        return $result[0]['fealtures'];    
    }
    
    /*опишем метод который вызывается в Login_Controller и записывает количество попыток неправильного ввода*/
    public function insert_fealt($ip) {
        /*обратимся к обьекту Model_Driver и его методу insert(),который вставляет данные в базу*/
        $this->ins_driver_u->insert(
                                    'fealtures',//это название таблички
                                    array('fealtures','ip','time'),//это поля -куда вставлять
                                    array('1',$ip,time())//это что вставляем в те поля
                                   );   
    }
    
    /*опишем метод который вызывается в Login_Controler и обновляет запись в таблице fealtures*/
    public function update_fealt($ip,$fealtures) {
        
        //сначала увеливаем на еденицу нашу пришедшию в параметре переменную $fealtures
        $fealtures++;
        
        /*и обращаемся к обьекту Model_Driver и его методу update,который обновляет данные*/
        $this->ins_driver_u->update(
                                    'fealtures',//таблица,которую обновляем
                                    array('fealtures','time'),//какие поля обновляем
                                    array($fealtures,time()),//какие значения заносим в те поля
                                    array('ip' => $ip)//т.е. где поле ip равно переменой ip
                                   );    
    }
    
    /*опишем метод,который очищает данные в таблице после прошествия одного дня.Этот метод вызывается
    в Login_Controllere*/
    public function clean_fealtures($time) {
        
        //вызываем метод на удаление
        $this->ins_driver_u->delete(
                                    'fealtures',
                                    array('time' => $time),
                                    array('<=')
                                   );    
    }
    /*опишем метод,который будет записывать id или возвращать,параметром приходит id и по умолчанию,
    ьф его поставили FALSE-это метод проверки индефикатора пользователя*/
    public function check_id_user($id = FALSE) {
        
        if($id) {// если id усть,то просто записываем его в свойство и возвращаем
            return $this->user_id = $id;    
        }
        /*если не передали id или оно = FALSE то мы попытаемся вытащить его из файла coockie*/
        else {
            /*проверим а существует ли вообще файл куки,т.е. существует ли в суперглобальном массиве COOKIE
            ключ с именем нашей куки USERNAME,первым параметром передаем сам ключ-этостатик свойство $cookie_name*/
            if(array_key_exists(self::$cookie_name,$_COOKIE)) {
                
                /*если есть то обратимся к методу который будет расшифровывать строку,параметром передадим
                ячейку суперглобального массива куки с ключем USERNAME- имя нашего файла куки*/
                $this->unpackage($_COOKIE[self::$cookie_name]);
                        
            }
            //если нет то генерируем мсключение
            else {
                throw new AuthException("Доступ закрыт: Авторизируйтесь!");
            }    
        }    
    }
    
    /*опишем метод который будет формировать строку для файла куки и вызываться в Login_Controllere*/
    public function set() {
        /*создадим перем.в которую сохраним строку которая запишется в куки,вызвав метод package*/
        $cookie_text = $this->package();
        
        /*теперь,когда скрипт ниже отработал и вернул сюда зашифрованою строку запишем ее в куки и параметрами
        ему передаем-имя куки файла, строку которую хотим записать,и третим время жизни кука(мы поставим 0,
        это значит,что он будет жить при работе сессии) и последним параметром пути создания куков*/
        if($cookie_text) {
            setcookie(self::$cookie_name,$cookie_text,0,SITE_URL);
            return TRUE;
        }
    }
    
    //опишем метод вызванный в предыдущем методе
    private function package() {
        if($this->user_id) {
            /*создадим промежут.перем.в которой будет хранить массив данных,которые будем записывать а куку*/
            $arr = array($this->user_id,time(),VERSION);//т.е.id ,время и версию куки нащу
            //теперь на основе этого масива сформируем строку с помощью ф-ии implode
            $str = implode($this->glue,$arr);//т.е.разделитель и массив
            /*теперь вернем эту строку,только в зашифрованом виде,для этого вызовем еще один метод*/
            return $this->encrypt($str);             
        }
        else {
            throw new AuthException("Не найден индефикатор пользователя:");
        }    
    }
    
    /*опишем метод который вызывается в предыдущем методе и шифрует строку*/
    private function encrypt($str) {
        /*создадим вектор инициализации для шифрования это все из расширения mcrypt и параметром ему
        передаем размер вектора,который тут же и получим в параметре,вызвав нужную ф-ю и передав ей
        наш дескриптор в качестве параметра*/
        $iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($this->td),MCRYPT_RAND);
        
        /*открываем буфер обмена и параметрами передаем дескриптор,ключ, и вектор*/
        mcrypt_generic_init($this->td,KEY,$iv);
        //теперь шифруем текст и сохраняем в переменную $crypt_text
        $crypt_text = mcrypt_generic($this->td,$str);
        //и закрываем буфер обмена
        mcrypt_generic_deinit($this->td);
        
        /*и возвращаем нашу строку с пристыкованым вектором инициализации,он понадобится для расшифровки*/
        return $iv.$crypt_text;    
    }
    
    //опишем метод который будет расшифровывать нашу строку,параметром передадим строку
    private function unpackage($str) {
        /*создадим переменную result и в неее сохраним отработку метода decrypt, по аналогии как с шифрованием*/
        $result = $this->decrypt($str);
        /*теперь с помощью ф-ии list,которая из масива создает переменные,запишем в наши свойства user_id,
        created,version, а что бы из строки сделать массив воспользуемся ф-ей explode,разделителем у нас служит
        свойство $this->glue*/
        list($this->user_id,$this->created,$this->version) = explode($this->glue,$result);
        //и возвращаем true,т.е. мы заполнили данные свойства
        return TRUE;          
    }
    
    /*опишем метод,вызываемый выше в методе, все по аналогии с шифрованием,только тут расшифровываем*/
    private function decrypt($str) {
        //получаем длину вектора инициализации
        $iv_size = mcrypt_enc_get_iv_size($this->td);
        //теперь получим обрезанием сам вектор из шифрованой строки
        $iv = substr($str,0,$iv_size);//т.е. обрезаем от нуля и до длины вектора иници,т.е.получаем вектор
        //теперь уже вырежем сам текст 
        $crypt_text = substr($str,$iv_size);
        //открываем буфер обмена,параметры-дескриптор,ключ,и вектор инициал.
        mcrypt_generic_init($this->td,KEY,$iv);
        /*теперь расшифровываем. параметром передаем дескриптор и сам зашифрованный текст*/
        //создадим переменную текс и в ней сохраним рашифрованый текст
        $text = mdecrypt_generic($this->td,$crypt_text);
        //закрываем буфер обмена
        mcrypt_generic_deinit($this->td);
        //и возвращаем расшифрованный текст
        return $text;
    }
    
    /*теперь опишем метод который вызывает в методе check_auth в Base_Controller и который будет сравнивать
    строку файла куки с нашими константами с конф.файла,т.е. не поменял ли злоумышленик файл куки*/
    public function validate_cookie() {
      
        /*проверим записано ли у нас в свойствах из куки что то и если нет то сразу генерируем исключ.*/
        if(!$this->user_id || !$this->created || !$this->version) {
            throw new AuthException("Не правильные данные.Доступ закрыт!");    
        }
        /*если записыны,то начнем по очереди проверять,соответствует ли они нашим константам,первым проверим
        версию файла кук*/
        if($this->version != VERSION) {
            throw new AuthException("Доступ закрыт!");    
        }
        /*теперь проверим механизм устаревания куки*/
        if((time() - $this->created) > EXPIRATION) {
            throw new AuthException("Время ушло! Авторизирутусь еще раз");    
        }
        /*теперь ,когда время ущу не вышло,что бы пользователь который работает в админки не отправило на
        авторизацию после прошествия EXPIRATION минут, нам надо обновить файл куки,для этого вызовем метод
        set() который записывает файл кук,теперь уже запишет с новым временем и админ сможет работать дальше*/
        if((time() - $this->created) > VARNING_TIME) {
            $this->set();    
        }
        
        return TRUE;
    }
    
    //опишем метод который будет выходить из системы для админки,который будет просто очисчать куки
    public function logout() {
        /*т.е.записываем пустую строку и время ставим уже давно прошедшее,например 1 час назад*/
        setcookie(self::$cookie_name,"",(time() - 3600),SITE_URL);
        return TRUE;    
    }       
}

?>