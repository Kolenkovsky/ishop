<?php
//Этот класс мы пишем только для этого сайта,он не является универсальным,могут быть другие задания
/*Опишем класс для постраничной навигации, этот класс не относится ни к модели ни к контроллеру - 
это что среднее имеющие признаки и контроллера и модели, это вспомогательный класс, вспомогательная библиотека,
он будетработать с базой данных минуя класс Model через класс Model_Draver*/
class Pager {
    
    protected $page;/*Здесь будем хранить номер текущей страницы,который будет браться из адресной строки
    и передаваться конструктору класса Pager*/
    protected $tablename;//Тут будет храниться имя таблицы из которой мы выбираем данные
    
    protected $where;//Тут хранится массив с данными по которым будет фильтрация выборки
    
    protected $order;// Сортировка.Тут указывается поле по которому будем сортировать данные как и в Model_Draver
    
    protected $napr;// Направление сортировки
    
    protected $operand;/*Операнд сортировки(<,>,=) lkz $where как и в Model_Driver*/
    
    protected $match;/*Тут массив для полнотекстового поиска,так как у нас есть поиск по сайту*/
    
    protected $post_number;/*Тут будем хранить количество записей которое необходимо выводить на
    одной странице,т.е. значение константы QUANTITY*/
    protected $number_link;/*Тут количество ссылок по левую и по правую сторону от текущей страницы,
    то есть значение константы QUANTITY_LINKS*/
    protected $db;//Здесь будет храниться обьект класса Model_Driver
    
    protected $total_count;//Здесь запишется полное количество всех записей таблицы(например новостей)
    
    
    /*Опишем конструктор класса, ему будем передавать несколько данных-номер страницы.название таблицы
    из которой будем выбберать,фильтрация(нужна или нет) и т.д.*/
    public function __construct(
                                $page,
                                $tablename,
                                $where = array(),//по умолчанию пустой массив
                                $order = '',//по умолчанию пусто
                                $napr = '',
                                $post_number,//это константа QUANTITY сюда
                                $number_link,
                                $operand = "=",
                                $match = array()
                               ) {
    /*Когда данные эти передадутся в наш конструктор запишем их в наши свойства*/
    $this->page = $page;//Т.е.свойство равно переменой которая пришла в качесве параметра конструктору
    $this->tablename = $tablename;
    $this->where = $where;
    $this->order = $order;
    $this->napr = $napr;
    $this->post_number = $post_number;
    $this->number_link = $number_link;
    $this->operand = $operand;
    $this->match = $match;
    
    /*Теперь запишем в наше свойство $db обьект класса Mjdel_Driver*/
    $this->db = Model_Driver::get_instance();
        
    }
    
    //Напишем метод,который будет подсчитывать общее количество данных,которых необходимо вывести
    public function get_total() {
        /*Сначала проверим есть ли у нас свойство $total_count,если нет то вызываем метод select
        и сохраняем резульатт в этом свойстве.Если же есть то просто его возвращаем*/
        if(!$this->total_count) {
        
        /*Обратимся к обьекту Model_Driver и его методу select*/
        $result = $this->db->select(
                                    array("COUNT(*) as count"),/*Т.е выбрать все записи как count*/
                                    $this->tablename,//название таблицы
                                    $this->where,//Фильтрация данных,обращаемся к свойству класса Pager
                                    $this->order,
                                    $this->napr,
                                    FALSE,//лимит нам не нужен
                                    $this->operand,
                                    $this->match
                                   );
         $this->total_count = $result[0]['count'];//Сщхраним это в свойстве $total_count
         }
         return $this->total_count;    
    }
    
    /*Теперь опишем метод который будет считать сколько нам надо страниц для вывода всех данных, а 
    потом будет формировать массив данных которые необходимо вывести на одной странице*/
    public function get_posts() {
        /*создадим переменую в которой будем хранить результат метода get_total*/
        $total_post = $this->get_total();
        
        /*Теперь посчитаем сколько страниц нам надо для вывода всего,создадим $number_pages т.е поделим*/
        $number_pages = (int)($total_post/$this->post_number);//И отрежим дробную часть (int)
        
        /*Если это деление будет с остатком,то нам надо добавить еще одну страницу,иначе все не влезет
        поэтому мы с помощью % проверим есть ли остаток от деления,если есть то увеличим еще на одну страницу
        если нет то ничего делать не будем*/
        if(($total_post%$this->post_number) != 0) {
            $number_pages++;    
        }
        
        /*Сделаем еще проверку а не прищло ли нам в свойство $page отрицательное или равное 0 число
        т.е. номер страницы должен быть положительным*/
        if($this->page <= 0 || $this->page > $number_pages) {
            return FALSE;//и если номер страницы больше чем количество страниц то FALSE    
        }
        
        /*Теперь мы уже можем формировать массив данных на вывод страниц, для этого напишем такую конструкции
        (чистая математика)создадим переменную $start и эта строка будет нам автоматически вычеслять
        с какого элемента надо брать следующие три записи*/
        $start = ($this->page - 1)*$this->post_number;
        
        //Теперь уже можем и выбрать данные из базы данных которые и выведим на экран,обратимся к методу select
        $result = $this->db->select(/*В масиве ниже вместо выбрать все мы можем записать свои поля,предварительно
    создав свойство например $fialds передать его конструктору и т.д. по аналогии*/
                                    array('*'),//Выбрать все/ смотри выше
                                    $this->tablename,
                                    $this->where,
                                    $this->order,
                                    $this->napr,
                                    $start.','.$this->post_number,//это лимит выборки так записан
                                    $this->operand,
                                    $this->match
                                   );
        
        return $result;  
    }
    
    /*Создадим метод который будет формировать массив данных непосредственно для нашей навигации*/
    public function get_navigation() {
        
        //Получаем общие количество записей
        $total_post = $this->get_total();
        
        /*Опять же как и в get_posts нам понадобится количество страниц которое нам необходимо для вывода
        так же как и в предыдущем методе*/
        $number_pages = (int)($total_post/$this->post_number);
        
        if(($total_post%$this->post_number) != 0) {
            $number_pages++;    
        }
        
        /*Опять же сделаем некоторые проверки.Проверим общее количество данных не меньше ли количества
        которое необходимо вывести на одной странице*/
        if($total_post < $this->post_number || $this->page > $number_pages ) {
        
        //Т.е.если общее колич.меньше чем то что выводится на одной стр.то навигацию выводить не надо    
            return FALSE;              
        }
        
        //Теперь формируем массив
        $result = array();//Создадим пустой массив
        
        /*Теперь нам надо проверит,если это не первая страница то надо чтобы были ссылки "предыдущая"
        и стрелочка в лево,если это первая то эти ссылки нам не нужны*/
        if($this->page != 1) {
            $result['first'] = 1; //Это для кнопки "Первая"Это мы создаем массив и его ячейку 'first'
            $result['last_page'] = $this->page - 1;/*Это стрелка на предыдущую,т.е. от текущей отнимаем 1*/
               
        }
        
        /*Теперь нам надо,чтобы перед текущей страницей отражалось ссылки на три предыдущих страницы,т.е. если
        у нас текущая допустим четвертая страница то должно быть 'first''<''1','2','3'. А если текущая пятая 
        страница то должно быть 'fist','<','2','3','4','5'т.е. "1" нам надо откинуть,поэтому проверим*/
        if($this->page > $this->number_link + 1) {
            /*Если выполняется условие то нвявло цикла надо брать от разницы: текущая минус количество ссылок*/
            for($i = $this->page - $this->number_link; $i < $this->page; $i++) {
                $result['previous'][] = $i;        
            }    
        }
        else {
            /*Если условие не выполняется,т.е. если текущая страница номер 2 а она < $this->number_link + 1
            то мы в цикле выведием нужные нам ссылки*/
            for($i = 1; $i < $this->page; $i++ ) {
                /*обратимся к переменой $result и создадим в ней ячейку 'previous' и присвоим ей значение $i
                т.е. мы в цикле выводим просто номера страниц*/
                $result['previous'][] = $i;//ячейка previous является массивом            
            }    
        }
        
        /*Создадим в нашем массиве $result ячейку current и присвоим ей значение текущей страницы*/
        $result['current'] = $this->page;
       
        //Теперь займемся выводом следующих после текущей ссылок на страницы,нам нужно сделать две проверочки
        //Если текущая + количество ссылок меньше чем общие количество необходимое кол-во стран.
        if($this->page+$this->number_link < $number_pages) {
            for($i = $this->page + 1; $i <= $this->page + $this->number_link; $i++) {
               $result['next'][] = $i;         
            }
                
        }
        //Блок else для вывода последней страницы если условие выше не выполняется
        else {
            for($i = $this->page + 1; $i <= $number_pages; $i++) {
                $result['next'][] = $i;     
            }    
        }
        
        //Теперь сформируем ссылку ">" и "Последняя"
        if($this->page != $number_pages) {
            $result['next_pages'] = $this->page + 1;
            $result['end'] = $number_pages;    
        }
                
        return $result; 
    }
    
}

?>