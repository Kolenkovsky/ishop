Как работает весь скрипт:

Когда мы в адрессной строке вводим localhost/ishop/catalog/, а не файл или папку то наш файл .htaccess 
перенаправляет нас на индексную страницу index.php

В файле index.php мы открываем сессии подключаем конфигурацию, устанавливаем пути загрузки файлов,делает 
автозагрузку классов

Далее он вызывает класс Route_Controller т.е. создает его обьект и сохраняет его в переменной $obj;
В классе Route_Controller у нас сразу же отрабатывает конструктор, т.е. он разбирает нашу адресную строку 
и смотрит какой контроллер  надо загрузить и если есть какие то параметры. 
Имя контролера он записывает в свойство $controller а масссив параметров в $params.

Далее в index.php мы у обьекта $obj класса Route_Controller вызываем метод route, 
который находится в Base_Controller, который проверяет  что у нас находится в свойстве $this->controller 
есть ли такой класс  есть у него метод request и если есть то запускает этот метод и передает ему параметры

Класс Base формирует входные данные,которые общие для всех страниц input- это 
заголовок,массив стилей и скриптов, далее получает обьект модели,далее обратится к модели 
и получит данные по шапке сайта,по меню,получит страницу данные по новостям из базы данных 
это все.
И в каждом классе который будет выводить страницы,мы сначала вызывает этот родительсский метод
parent::input,который выполняется сначала, а потом мы дополняем код который уникальный для
этой именно страницы.
Метод output уже генерирует готовую страницу.Поэтому в контроллере страницы мы сначала формируем
те блоки которые отличаются у страниц, а затем обращаемся к родительскому классу Base к методу
parent::output который генерирует остальные блоки и вызывает на генерацию главный шаблон
нашего сайта т.е. файл index.php который и собирает все блоки воедино.

Когда запускается Index_Controller мы генерируем страницу $this->text, формируем два свойства $this->keywords 
и $this->discription родительского класса Base, далее генерируем в методе output блок $this->content так как он
уникальный для этой страницы и дальше вызываем родительский метод output ($this->page = parent::output())
который генерирует левый блок,блок новостей, футер и шапку сайта используя свойства $keywords и 
$discription которые уже сформированы в методе input нашего Index_Controller. И далее сгенерируется общий шаблон $page

Когда мы создаем контролер отвечающий за вывод страницы,мы должны обьязательно переопроеделить два метода-это
метод input и output.И в каждом из них вызвать родительские методы parent::input и parent::output.
Только в иетоде input родительский метод вызывается в начале и потом дописывается код свойственной
этой странице, а в методе output сначала идет свой код,что то генерируется а потом в конце обращаемся к свойству page в
котором сохраняли отработку родительского метода output  который делает вещи общие для всех страниц.
Метод input должен принять параметры,которые считал Rout_Conroler и передал методу request класса Base_Contr.

            <ЛОГИКА РАБОТЫ ПОСТРАНИЧНОЙ НАВИГАЦИИ>
Сначала мы подсчитываем какое количество данных существует в базе данных,которое необходимо вывести
Затем мы общее колличество делим на QUANTITY т.е. число сколько статей мы выводим на одной странице-мы
узнаем сколько нам нужно для этого страниц.Затем мы сформилируем запрос для вывода первой страницыт.е.
для вывода первых QUANTITY записей,а второй массив вернет нам ссылки для перехода на другие страницы

Когда мы создаем контролер который выводит архив новосте или каталог товаров,то есть где данных много
мы выбираем данныу не обращаясь к модели а обращаемся к классу Pager так как новостей много и страниц будет 
не одна, поэтому нужная постраничная навигация.А класс Pager своим методом get_posts() к которому мы
обращаемся из нашего контролера сформирует нам массив данных из базы и нам останется его только вывести
на экран через шаблон.

                    <Полнотекстовый поиск>
Для полнотекстового поиска нам надо сформулировать такой запрос примерно"*SELECT title,text FROM
tovar WHERE MATCH(title,text) AGAINST('текст запроса')*".Для поиска нам надо создать интукс типа
fool text для полей в которых мы будем искать, в нашем случае это поля title и text.

                     <!Для контроллера Pricelist>
Когда мы создаем обьект главного класса библиотеки PHPExcel .то конструктор этого класса в своей работе
создает обьекты других классов библиотеки, а так как в файле Index.php мы прописали пути для загрузки файлов,
а там нет пути к библиотеке и ее папкам,где и находятся те классы то возникнет ошибка при автоматической
загрузке классов в Index.php. Поэтому есть два пути, либо в методе автозагрузки классов файла Index.php
перед основной загрузкой поставить проверку не начинается ли имя класса с PHPExcel -так как все классы 
библиотеки начинаются с этого,и если есть -то то мы нашу автоматическую загр.классов дальше делать не будем,
а если нет такого префикса то по стандартному методу дальше наш код пойдет на автозагрузку.
    Второй путь это при обьявлении класса использовать префиксы(PREFIX_Pricelist_Controller, а дальше
в автоматической автозагрузке классов также проверять есть ли префикс)

"var_dump($this->objPHPExcel);-с помощью этой ф-ии можно проверить что находится в свойстве" 

////////////////////////////////////////////////////////////////////////////////////////////////////
                  <!ГЕНЕРАЦИЯ ИСКЛЮЧЕНИЙ И РАБОТА С ОШИБКАМИ>
                  
Класс ContrException и класс Exception будуть работать с ошибками ,когда например пользователь в адресной
строке не указал какихто параметров например значение id/ или не правильно указал адресс сайта в конфигурационом
файле_это все проверяется в RoutControllere или в классе Base_Controller так же проверяется есть ли контролер
который вызывается.
    Логика работы с ошибкамию.Если произошла ошибка например  ContrException, он обрабатывает ее получает данные
о файле в котором ошибка о строке в которой ошибка и перенаправляет нас на Error_Controller, он в 
свою очередь принимает параметры из адресной строки ,обрабатывает их, из сессии вытаскиваем данные,формирует
свойство $error и $message_err ,попадаем в родительский класс Base_Error к которому мы обращаемся в методе output
Error_Controllera, там генерируется щаблон и отдается в дочерний класс Error_Controler,а тот в свою очередь
уже возвращает готовую страницу к выводу,т.е. в свойстве $page у нас уже лежит полностью готовая к выводу
страница.
Сформированное в Error_Controllere свойство $error описанное в Base_Controllere,запишется туда,а в 
Base_Controllere есть метод request который описывает что за чем должно выводиться и проверяет,если свой
ство $error не пустое,то он вызывает метод write_error, который записывает ошибки в log.php
////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////// А  В  Т  О  Р  И  З  А  Ц  И  Я ///////////////////////////////////////
Мы на этом сайте сделаем авторизацию не по стандартномо пути.В стандартном виде авторизация проходит
проверку данных пользователя в базе данных и если данные верны то создается запись в сессии с каким то
определенным содержимым,например случайно сгенерированной строкой,и затем при листании по страницам админ-
ки всегда проверяется присутствуют ли данные об авторизации,т.е. та случайно сгенерированная строка,
то считается что пользователь авторезирован.
    Мы будет делать нашу авторизацию на файлах cooci. Это будет происходить так.Когда пользователь вводит
пароль и логин,мы проверяем есть ли в базе данных такие и если есть,то мы формируем определенную строку
и записываем ее в cooci,только запишем в определенном формате и в зашифрованном виде. И дальше когда пользо
ватель будет по страничкам админки ходить мы будет проверять есть куки-файл с требуемым именем мы его
проверяем ага есть там действительно правильно сформированная строка,тогда мы его считаем авторизированным.
Куки - это некоторое количество информации которое имеет свое имя и может храниться в настройках браузере,
между различными сеансами ,т.е. это такое не большое хранилище,когда пользователь делает переходы по 
страницам куки не изменяются,конечно если это не прописать в скрипте.Т.е.с помощью куков мы можем 
сохранить небольшое количсество информации прямо в браузере не используя базу данных. И эти данные будут
иметь отношение к конкретному пользователю,т.к.они уже сохранены у конкретного пользователя на компьютере
в браузере.У каждого куки есть определенное время жизни,по достижении которого они автоматичски уничтожаются.
.................................ЛОГИКА АВТОРИЗАЦИИ...............................................



